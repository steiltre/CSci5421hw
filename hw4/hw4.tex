%        File: hw4.tex
%     Created: Wed Oct 26 04:00 PM 2016 C
% Last Change: Wed Oct 26 04:00 PM 2016 C
%

\documentclass[a4paper]{article}

\title{CSci 5421 Homework 4 }
\date{11/9/16}
\author{Trevor Steil}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{esint}
\usepackage{enumitem}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem*{claim}{Claim}
\newtheorem*{problem}{Problem}
%\newtheorem*{lemma}{Lemma}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\supp}[1]{\mathop{\mathrm{supp}}\left(#1\right)}
\newcommand{\lip}[1]{\mathop{\mathrm{Lip}}\left(#1\right)}
\newcommand{\curl}{\mathrm{curl}}
\newcommand{\la}{\left \langle}
\newcommand{\ra}{\right \rangle}
\renewcommand{\vec}[1]{\mathbf{#1}}

\newenvironment{solution}{\emph{Solution.}}

\begin{document}
\maketitle
\begin{enumerate}
  \item
    \begin{problem}

      Recall the problem of task scheduling with deadlines and penalties (Sec. 16.5), which was discussed in class. This was solved using the generic
      greedy algorithm for matroid optimization (Sec. 16.4). A key step in the algorithm is to test at each iteration whether a given set, $A$, of
      tasks is independent, i.e., whether there exists a schedule in which no task of $A$ is late. This can be accomplished by using the following
      fact: ``$A$ is independent if and only if $N_t(A) \leq t$ for $t=0,1,\dots,n$.'' Here $N_t(A)$ is the number of tasks in $A$ with deadline at
      most $t$.

      Give an algorithm that tests if $A$ is independent in $\Theta(|A|)$ time. Your answer should include a brief explanation of the key ideas behind
      your approach, pseudocode, and run-time analysis. (Note that a running time of $\Theta(n)$ is easy to achieve but is too large when $|A| \ll n$.)

      Hint: Consider limiting the range of values of $t$ that need to be checked in the fact stated above. Be sure to justify your reasoning.

    \end{problem}

    \begin{solution}

    \end{solution}

  \item
    \begin{problem}

      Ex. 13.2-4

      Show that any arbitrary $n$-node binary search tree can be transformed into any other arbitrary $n$-node binary search tree using $O(n)$
      rotations. (Hint: First show that at most $n-1$ right rotations suffice to transform the tree into a right-going chain.)

      A careful, well-ordered answer should be given. Pseudocode is not required.

    \end{problem}

    \begin{proof}

    \end{proof}

  \item

    \begin{problem}

      Problem 12-2

      Given two strings $a = a_0 a_1 \dots a_p$ and $b = b_0 b_1 \dots b_q$, where each $a_i$ and each $b_j$ is in some ordered set of characters, we
      say that string $a$ is \textbf{lexicographically less than} string $b$ if either
      \begin{enumerate}
        \item ther exists an integer $j$, where $0 \leq j \leq min(p,q)$, such that $a_i = b_i$ for all $i=0,1,\dots,j-1$ and $a_j < b_j$, or

        \item $p < q$ and $a_i = b_i$ for all $i = 0,1,\dots,p.$

      \end{enumerate}

      The \textbf{radix tree} data structure shown in Figure 12.5 stores the bit strings 1011, 10, 011, 100, and 0. When searching for a key $a = a_0
      a_1 \dots a_p$, we go left at a node of depth $i$ if $a_i = 0$ and right if $a_i = 1$. Let $S$ be a set of distinct bit strings whose lengths
      sum to $n$. Show how to use a radix tree to sort $S$ lexicographically in $\Theta(n)$ time.

      Describe, in words, the key ideas behind the tree-building and sorting algorithms, give pseudocode for both, and show that each takes
      $\Theta(n)$ time.

      Note that the radix tree is not given to you; you must build it from the given set of strings and then use this to sort. (So the time to sort
      includes the time to build the tree.) Note that there is no need to store the strings explicitly at the nodes; see the caption for Figure 12.5

    \end{problem}

    \begin{solution}

    \end{solution}

  \item

    \begin{problem}

      Ex. 13.3-5

      Professor Teach is concerned that \texttt{RB-INSERT-FIXUP} might set $T.nil.color$ to \texttt{RED}, in which case the test in line 1 would not cause
      the loop to terminate when $z$ is the root. Show that the professor's concern is unfounded by arguing that \texttt{RB-INSERT-FIXUP} never sets
      $T.nil.color$ to \texttt{RED}.

      A careful proof is expected. Consider using induction on $n$ and examining the various cases that can arise in \texttt{RB-INSERT-FIXUP} (see
      also Figures 13.5 and 13.6)).

    \end{problem}

    \begin{solution}

    \end{solution}

  \item

    \begin{problem}

      Problem 13.2 \textbf{Join operation on red-black trees}

      The \textbf{join} operation takes two dynamic sets $S_1$ and $S_2$ and an element $x$ such that for any $x_1 \in S_1$ and $x_2 \in S_2$, we have
      $x_1.key \leq x.key \leq x_2.key$. It returns a set $S = S_1 \cup \{x\} \cup S_2$. In this problem, we investigate how to implement the join
      operation on red-black trees.

      \begin{enumerate}
        \item Given a red-black tree $T$, let us store its black-height as the new attribute $T.bh.$ Argue that \texttt{TB-INSERT} and
          \texttt{RB-DELETE} can maintain the $bh$ attribute without requireing extra storage in the nodes of the tree and without increasing the
          asymptotic running times. Show that while descending through $T$, we can determine the black-height of each node we visit in $O(1)$ time per
          node visited.
      \end{enumerate}

      We wish to implement the operation \texttt{RB-JOIN($T_1,x,T_2$)}, which destroys $T_1$ and $T_2$ and returns a red-black tree $T = T_1 \cup
      \{x\} \cup T_2$. Let $n$ be the totatl number of nodes in $T_1$ and $T_2$.

      \begin{enumerate}[resume]

        \item
          Assume that $T_1.bh \geq T_2.bh$. Describe an $O(\lg n)$-time algorithm that finds a black node $y$ in $T_1$ with the largest key from among
          those nodes whose black-height is $T_2.bh$.

        \item Let $T_y$ be the subree rooted at $y$. Describe how $T_y \cup \{x\} \cup T_2$ can replace $T_y$ in $O(1)$ time without destroying the
          binary-search-tree property.

        \item
          What color should we make $x$ so that red-black properties 1,3, and 5 are maintained? Describe how to enforce properties 2 and 4 in $O( \lg
          n)$ time.

        \item
          Skip because it is symmetric to part (b)

        \item
          Argue that the running time of \texttt{RB-JOIN} is $O( \lg n)$.

      \end{enumerate}

      Supplement your answer with short code fragments, as appropriate.

    \end{problem}

    \begin{solution}

    \end{solution}

  \item

    \begin{problem}

      Let $T$ be a red-black tree with $n$ nodes, where each node has the usual fields: key, color, and pointers to its parent and children. In
      addition, each internal node $x$ has an auxiliary field, \texttt{diff}, whose value is the difference between $x$'s key and the minimum key in
      the subtree rooted at $x$ (the subtree includes $x$). The auxiliary field is not of interest for external nodes.

      Argue carefully, using the General Augmentation Theorem (GAT), that the auxiliary field can be maintained during insertions and deletions
      without affecting the $O( \log n)$ time bounds for these operations. (You cannot store any other information in the nodes.)

      Note: You must use the GAT to make your argument, rather than trying to argue from first principles.

    \end{problem}

    \begin{solution}

    \end{solution}

\end{enumerate}
\end{document}


