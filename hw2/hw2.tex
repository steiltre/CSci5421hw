%        File: hw2.tex
%     Created: Mon Sep 26 04:00 PM 2016 C
% Last Change: Mon Sep 26 04:00 PM 2016 C
%

\documentclass[a4paper]{article}

\title{CSci 5421 Homework 2}
\date{10/5/16}
\author{Trevor Steil}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{esint}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{algorithm}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem*{claim}{Claim}
\newtheorem*{problem}{Problem}
%\newtheorem*{lemma}{Lemma}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\supp}[1]{\mathop{\mathrm{supp}}\left(#1\right)}
\newcommand{\lip}[1]{\mathop{\mathrm{Lip}}\left(#1\right)}
\newcommand{\curl}{\mathrm{curl}}
\newcommand{\la}{\left \langle}
\newcommand{\ra}{\right \rangle}
\renewcommand{\vec}[1]{\mathbf{#1}}

\newenvironment{solution}[1][]{\emph{Solution #1}}

\algnewcommand{\Or}{\textbf{ or }}
\algnewcommand{\And}{\textbf{ and }}

\begin{document}
\maketitle

\begin{enumerate}
  \item
    \begin{problem}
      Use the \textit{bottom-up} (i.e., iterative) algorithm \texttt{MATRIX-CHAIN-ORDER(p)} seen in class to determine the minimum number of
      multiplications needed to compute the product of a sequence of six matrices whose dimensions are $p = \la p_0, p_1, \dots, p_6 \ra = \la 30, 1,
      40, 10, 25, 50, 5 \ra$. You must show your work, i.e., the filled-in lookup table, the optimal parenthesization, and its cost.
    \end{problem}

    \begin{solution}

    We will fill in the lookup table according to values of $\delta = j-i$. For $\delta=0$ we have $m_{ij} = 0$ for all $i=j$.
    \vspace{-.2cm}
    \begin{equation*}
      \begin{aligned}[c]
      &\delta = 1 \\
      &\quad i=1, j=2 \\
      &\quad \quad k=1 \\
      &\quad \quad \quad 30*1*40 = 1200 \\
      &\quad m_{12} = 1200\\
      &\quad i=2, j=3 \\
      &\quad \quad k=2 \\
      &\quad \quad \quad 1 * 40 * 10 = 400 \\
      &\quad m_{23} = 400 \\
      &\quad i=3, j=4 \\
      &\quad \quad k=3 \\
      &\quad \quad \quad 40 * 10 * 25 = 10000 \\
      &\quad m_{34} = 10000 \\
      &\quad i=4, j=5 \\
      &\quad \quad k=4 \\
      &\quad \quad \quad 10 * 25 * 50 = 12500 \\
      &\quad m_{45} = 12500 \\
      &\quad i=5, j=6 \\
      &\quad \quad k=5 \\
      &\quad \quad \quad 25*50*5=6250 \\
      &\quad m_{56} = 6250
    \end{aligned}
    \quad \quad
    \begin{aligned}[c]
      &\delta=2 \\
      &\quad i=1, j=3 \\
      &\quad \quad k=1 \\
      &\quad \quad \quad 400 + 30*1*10 = 700 \\
      &\quad \quad k=2 \\
      &\quad \quad \quad 1200 + 30*40*10 = 13200 \\
      &\quad m_{13} = 700 \\
      &\quad i=2, j=4 \\
      &\quad \quad k=2 \\
      &\quad \quad \quad 10000+1*40*25=11000 \\
      &\quad \quad k=3 \\
      &\quad \quad \quad 400+1*10*25=650 \\
      &\quad m_{24}=650 \\
      &\quad i=3, j=5 \\
      &\quad \quad k=3 \\
      &\quad \quad \quad 12500+40*10*50=32500 \\
      &\quad \quad k=4 \\
      &\quad \quad \quad 10000+40*25*50=60000 \\
      &\quad m_{35} = 32500 \\
      &\quad i=4, j=6 \\
      &\quad \quad k=4 \\
      &\quad \quad \quad 6250+10*25*5=7500 \\
      &\quad \quad k=5 \text{ gives a bigger result} \\
      &\quad m_{46}=7500
    \end{aligned}
  \end{equation*}

  \begin{equation*}
    \begin{aligned}[c]
      &\delta=3 \\
      &\quad i=1, j=4 \\
      &\quad \quad k=1 \\
      &\quad \quad \quad 650 + 30*1*25=1400 \\
      &\quad \quad k=2 \text{ gives a bigger result} \\
      &\quad \quad k=3 \\
      &\quad \quad \quad 700+30*10*25=8200 \\
      &\quad m_{14} = 1400 \\
      &\quad i=2, j=5 \\
      &\quad \quad k=2 \\
      &\quad \quad \quad 32500+1*40*50=34500 \\
      &\quad \quad k=3 \\
      &\quad \quad \quad 400+12500+1*10*50=13400 \\
      &\quad \quad k=4 \\
      &\quad \quad \quad 650+1*25*50=1900 \\
      &\quad m_{25}=1900
      &\quad i=3, j=6 \\
      &\quad \quad k=3 \\
      &\quad \quad \quad 7500+40*10*5=9500 \\
      &\quad \quad k=4 \\
      &\quad \quad \quad 10000+6250+40*25*5=17500 \\
      &\quad \quad k=5 \text{ gives a bigger result} \\
      &\quad m_{36}=9500
    \end{aligned}
    \quad \quad
    \begin{aligned}[c]
      &\delta=4 \\
      &\quad i=1, j=5 \\
      &\quad \quad k=1 \\
      &\quad \quad \quad 1900+1*40*50=3900 \\
      &\quad \quad k=2 \text{ gives a bigger result} \\
      &\quad \quad k=3 \text{ gives a bigger result} \\
      &\quad \quad k=4 \\
      &\quad \quad \quad 1400+30*25*50=38900 \\
      &\quad m_{15} = 3900 \\
      &\quad i=2, j=6 \\
      &\quad \quad k=2 \\
      &\quad \quad \quad 9500+1*40*5=9700 \\
      &\quad \quad k=3 \\
      &\quad \quad \quad 400+7500+1*10*5=7950 \\
      &\quad \quad k=4 \\
      &\quad \quad \quad 650+6250+1*25*5=7025 \\
      &\quad \quad k=5 \\
      &\quad \quad \quad 1900+1*50*5=2150 \\
      &\quad m_{26}=2150
    \end{aligned}
  \end{equation*}

  \begin{equation*}
    \begin{aligned}[c]
      &\delta=5 \\
      &\quad i=1, j=6 \\
      &\quad \quad k=1 \\
      &\quad \quad \quad 2150 + 30*1*5=2300 \\
      &\quad \quad k=2 \text{ gives a bigger result} \\
      &\quad \quad k=3 \text{ gives a bigger result} \\
      &\quad \quad k=4 \text{ gives a bigger result} \\
      &\quad \quad k=5 \text{ gives a bigger result} \\
      &\quad m_{16} = 2300
    \end{aligned}
    \hspace{6.7cm}
  \end{equation*}

  This gives the following lookup table.

    \[
    \begin{bmatrix}

      0 & 1200 & 700 & 1400 & 3900 & 2300 \\
      * & 0 & 400 & 650 & 1900 & 2150 \\
      * & * & 0 & 10000 & 32500 & 9500 \\
      * & * & * & 0 & 12500 & 7500 \\
      * & * & * & * & 0 & 6250 \\
      * & * & * & * & * & 0

    \end{bmatrix}
    \]

    Therefore, the optimal parenthesization requires 2300 scalar multiplications and is given as $A_1 * ((( (A_2 * A_3) * A_4) * A_5) * A_6)$.

  \end{solution}

  \item
    \begin{problem} Ex 15.2-5
      Let $R(i,j)$ be the number of times that table entry $m[i,j]$ is referenced while computing other table entries in a call of
      \texttt{Matrix-Chain-Order}. Show that the total number of references for the entire table is
      \[ \sum_{i=1}^n \sum_{j=1}^n R(i,j) = \frac{n^3 - n}{3} .\]
    \end{problem}

    \begin{solution}[1]

      By looking at the algorithm, we can see for $j \geq i$ that $m[i,j]$ is used to calculate all values in the table to the right of position
      $(i,j)$ or above position $(i,j)$ in the lookup table. Therefore, we have
      \[ R(i,j) =
        \begin{cases}
          0 &\text{if } i > j \\
          (i-1) + (n-j) &\text{else}
        \end{cases}
      \]
      because there are $i-1$ entries above position $(i,j)$ and $n-j$ entries to the right of position $(i,j)$ in the lookup table.

      Now we can compute
      \begin{align*}
        \sum_{i=1}^n \sum_{j=1}^n R(i,j) &= \sum_{i=1}^n \sum_{j=i}^n n+i-j-1 \\
        &= \sum_{i=1}^n (n-i+1)(n+i-1) - \frac{n(n+1)}{2} + \frac{i(i-1)}{2} \\
        &= \sum_{i=1}^n n^2 - i^2 +2i - 1 -\frac{1}{2} n^2 - \frac{1}{2} n + \frac{1}{2} i^2 -\frac{1}{2} i \\
        &= \frac{1}{2} n^3 - \frac{1}{2}n^2 - n - \frac{n(n+1)(2n+1)}{12} + \frac{3n(n+1)}{4} \\
        &= \frac{1}{2} n^3 - \frac{1}{2} n^2 - n - \frac{n^3}{6} - \frac{n^2}{4} - \frac{n}{12} + \frac{3n^2}{4} + \frac{3n}{4} \\
        &= \frac{n^3}{3} - \frac{n}{3}
      \end{align*}

    \end{solution}

    \begin{solution}[2]

      An alternative (and simpler) solution is to realize that we don't have to explicitly calculate $R(i,j)$ and can instead use the structure of the
      loops in the algorithm. We see that we loop over the diagonals of our lookup table placing entries as we go. We have $\delta = j-i$ taking
      values from 1 to $n-1$. Then $i$ takes values from 1 to $n-\delta$. We assign $j = i + \delta$, and then we compute the number of
      multiplications we could get from each of the $\delta$ possible ways of splitting the product. Each of these possibilities requires looking up 2
      values from the lookup table. So we have
      \begin{align*}
        \sum_{i=1}^n \sum_{j=1}^n R(i,j) &= 2 \sum_{\delta=1}^{n-1} (n-\delta) \delta \\
        &= n^2 (n-1) - \frac{n(n-1)(2n-1)}{3} \\
        &= n^3 - n^2 - \frac{2}{3}n^3 + n^2 - \frac{1}{3}n \\
        &= \frac{n^3 - n}{3}
      \end{align*}
    \end{solution}

  \item
    \begin{problem}
      Give a top-down, memoized version of the algorithm \texttt{LCS-LENGTH(X,Y)} to compute, in $O(mn)$ time, the length of a longest common
      subsequence of strings $X$ and $Y$, where $m=|X|$ and $n=|Y|$. (You do not have to retrieve the \texttt{LCS} itself; just compute its length.)
      Give a careful analysis of the running time.
    \end{problem}

    \begin{solution}

      We will let our strings be given by $X = x_1 x_2 \dots x_m$ and $Y = y_1 y_2 \dots y_n$. We give the algorithm as

      \begin{algorithm}
        \begin{algorithmic}[1]
        \Function{Memoized-LCS}{$X,Y$}
          \For{ $i \gets 1 .. m$ }
          \For{ $j \gets 1 .. n$ }
          \State $l[i,j] \gets \infty$
          \EndFor
          \EndFor

          \State \texttt{Lookup-LCS}$(X,Y,length(X), length(Y))$
        \EndFunction
        \end{algorithmic}

        \vspace{1cm}

        \begin{algorithmic}[1]
        \Function{Lookup-LCS}{$X,Y,i,j$}
          \If{ $l[i,j] < \infty$ }
          \Return $l[i,j]$
          \Else
          \If{ $i=0 \Or j=0$ }
          \State $l[i,j] \gets 0$
          \ElsIf{ $x_i = x_j $}
          \State $l[i,j] \gets \texttt{Lookup-LCS}(X,Y,i-1,j-1)$
          \ElsIf{ $l[i-1,j] \geq l[i,j-1]$ }
          \State $l[i,j] \gets \texttt{Lookup-LCS}(X,Y,i-1,j)$
          \Else
          \State $l[i,j] \gets \texttt{Lookup-LCS}(X,Y,i,j-1)$
          \EndIf
          \EndIf
          \State
          \Return $l[i,j]$
        \EndFunction
        \end{algorithmic}
      \end{algorithm}

      We can divide calls to \texttt{Lookup-LCS} into Type 1 calls in which $l[i,j]$ must be computed and Type 2 calls in which the value of $l[i,j]$
      is retrieved from the table.

      For each entry in the table, there can be at most one Type 1 call because after the value of $l[i,j]$ is computed, it is stored in the table for
      future lookups. To compute $l[i,j]$ previous values of $l[i,j]$ are looked up and compared, both of which take $O(1)$ time. Because there are
      $mn$ entries in the lookup table, we get a contribution of $O(mn)$ to our running-time from Type 1 calls to \texttt{Lookup-LCS}.

      When trying to find the value of $l[i,j]$, \texttt{Lookup-LCS} is only called to lookup values for $l[i-1,j], l[i,j-1]$, and $l[i-1,j-1]$.
      Thinking of this instead to tell us where $Lookup-LCS(X,Y,i,j)$ can be called from, we see the only possible locations in the table to make such
      a call would have to come from positions directly below $l[i,j]$, directly right of $l[i,j]$, or one entry right and one entry down from
      $l[i,j]$. Because of this, there can be at most 3 Type 2 calls performed on any entry in our lookup table (there can actually only be 2 because
      the first call would have to be a Type 1 call). Each Type 2 call requires $O(1)$ time, so the Type 2 calls contribute a running time of $O(mn)$
      to the total running time.

      Combining the running times from Type 1 and Type 2 calls to \texttt{Lookup-LCS}, we see the running time of \texttt{Memoized-LCS} is $O(mn)$.

    \end{solution}

  \item
    \begin{problem}
      This problem explores an improvement in the $\Theta(n^3)$ running time of the algorithm \texttt{OPTIMAL-BST} (Sec 15.5). It can be shown that
      the optimal root, $root_{ij}$, satisfies $root_{i,j-1} \leq root_{ij} \leq root_{i+1,j}$, $1 \leq i < j \leq n$. (You may assume this result
      without proof). Using this result, rewrite the algorithm \texttt{OPTIMAL-BST} and prove carefully that it runs in time $\Theta(n^2)$.
    \end{problem}

  \item
    \begin{problem}
      Ex. 25.2-4 Justify your answers carefully
    \end{problem}

  \item
    \begin{problem}

      Consider the problem of transforming a string, $A = a_1 a_2 \dots a_m$, of characters into another string, $B=b_1 b_2 \dots b_n$, by a sequence
      of insert(I), delete(D), and substitute(S) operations.

      Our goal is to come up with a transformation that minimizes the total number of I,D, and S operations. Define the edit distance between two
      strings as the minimum number of I,D, and S operations needed to transform the first string into the second. Design a bottom-up dynamic
      programming algorithm to compute the edit distance between $A$ and $B$ in time $\Theta(mn)$. The output is the edit distance and the
      corresponding operations.

      Your answer should include (i) a brief description of the main ideas, including the recurrence equation and its justifications, (ii) pseudocode,
      and (iii) an analysis of the running time.

      Hint: Let $e(i,j)$ be the edit distance between $a_1, \dots, a_i$ and $b_1, \dots, b_j$.

    \end{problem}

  \item
    \begin{problem}
      Consider the following multiplication table defined on an alphabet $\Sigma = \{a, b\}$.

      \large{\textbf{INSERT TABLE}}

      The rows correspond to the left operand and the columns to the right operand; thus, $aa = b, ab = a,$ etc.

      Design a bottom-up dynamic programming algorithm which takes a string $X = x_1 x_2 \dots x_n$, where each $x_i \in \Sigma$, and outputs ``true''
      if there is a parenthesization of $X$ for which the expression evaluates to $a$ (under the above multiplication table) and ``false'' otherwise.
      (You do not have to compute the parenthesization itself if the output is ``true''). The target time bound is $\Theta(n^3)$.

      Your answer should include (i) a brief description of the main ideas, including the recurrence equation and its justification, (ii) pseudocode,
      and (iii) an analysis of the running time.

      Note: This is a decision problem, not an optimization problem. Such problems can also be solved sometimes via dynamic programming.

      Hint: Let $a_{ij}$ (resp. $b_{ij}$) be ``true'' if there is a parenthesization of $x_1 x_2 \dots x_j$ which evaluates to $a$ (res. $b$) and
      ``false'' otherwise.

    \end{problem}

\end{enumerate}
\end{document}


