%        File: hw6.tex
%     Created: Wed Nov 30 04:00 PM 2016 C
% Last Change: Wed Nov 30 04:00 PM 2016 C
%

\documentclass[a4paper]{article}

\title{CSci 5421 Homework 6}
\date{12/14/16}
\author{Trevor Steil}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{esint}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{bbm}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem*{claim}{Claim}
\newtheorem*{problem}{Problem}
%\newtheorem*{lemma}{Lemma}
\newtheorem{definition}{Definition}[section]

\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\supp}[1]{\mathop{\mathrm{supp}}\left(#1\right)}
\newcommand{\lip}[1]{\mathop{\mathrm{Lip}}\left(#1\right)}
\newcommand{\curl}{\mathrm{curl}}
\newcommand{\la}{\left \langle}
\newcommand{\ra}{\right \rangle}
\renewcommand{\vec}[1]{\mathbf{#1}}

\newenvironment{solution}[1][]{\emph{Solution #1}}

\algnewcommand{\Or}{\textbf{ or }}
\algnewcommand{\And}{\textbf{ or }}

\begin{document}
\maketitle
\begin{enumerate}
  \item
    \begin{problem}
      Suppose that a stack, $S$, has $s>0$ items on it initially and an arbitrary sequence of $n$ \texttt{PUSH} and \texttt{MULTIPOP} operations is
      executed. Use the potential method of amortized analysis to show that the total actual cost of the sequence is $O(n)$, if $n = \Omega(s)$.

      Note: You will find the discussion beginning at the bottom of page 461 helpful.
    \end{problem}

    \begin{solution}

      This is the same as the potential method starting from an empty stack with a slight modification when amortized costs are summed. As before we
      define our potential function to be
      \[ \varphi(S) = |S|, \]
      that is, our potential function is the size of the stack. We then define $\widehat{c}_i = c_i + \varphi_i - \varphi_{i-1}$ where $\widehat{c}_i$
      is the amortized cost of the $i^{th}$ operation, $c_i$ is the actual cost of the $i^{th}$ operation, and $\varphi_i$ is the potential function
      after the $i^{th}$ operation. This leads to the same amortized costs as before:
      \[ \widehat{c}_i =
        \begin{cases}
          2 &\text{ if $i^{th}$ operation is \texttt{PUSH} } \\
          0 &\text{ if $i^{th}$ operation is \texttt{MULTIPOP} .}
        \end{cases}
      \]

      Then we have
      \begin{align*}
        \sum_{i=1}^n \widehat{c}_i &= \sum_{i=1}^n (c_i + \varphi_i - \varphi_{i-1}) \\
        &= \sum_{i=1}^n c_i + \varphi_n - \varphi_0 \quad \parbox{5cm}{because of the telescoping sum} \\
        &= \sum_{i=1}^n c_i + \varphi_n - s \quad \parbox{5cm}{because stack initially contains $s$ elements}
      \end{align*}

      Because $\varphi_n \geq 0$ by definition, we get the upper bound
      \[ s + \sum_{i=1}^n \widehat{c}_i \geq \sum_{i=1}^n c_i .\]
      By definition, $\widehat{c}_i = O(1)$, so
      \[ s + O(n) \geq \sum_{i=1}^n c_i .\]
      We assumed $n = \Omega(s)$, which is equivalent to $s = O(n)$, so
      \[ \sum_{i=1}^n c_i = O(n) .\]

    \end{solution}

  \item
    \begin{problem}
      Show the Fibonacci heap that results from performing a \texttt{FIB-HEAP-DELETE-MIN} operation on the Fibonacci heap, $h$, given in the
      assignment. Show intermediate steps (including those done during consolidation) and marked nodes clearly. (Marked nodes are indicated by a '*'.)
      For consistency, do consolidation starting from the root to the right of the current minimum node.
    \end{problem}

    \begin{solution}
      See attachment at end.
    \end{solution}

  \item Problem 19-1
    \begin{problem}
      \textbf{Alternative implementation of deletion}

      Professor Pisano has proposed the following variant of the \texttt{FIB-HEAP-DELETE} procedure claiming that it runs faster when the node being
      deleted is no the node pointed to by $H.min.$

      \begin{algorithmic}[1]
        \Function {Pisano-Delete}{$H,x$}

        \If{ $ x = H.min$ }
        \State \texttt{FIB-HEAP-EXTRACT-MIN}$(H)$
        \Else
        \State $y \gets x.p$
        \If{ $y \neq H.nil$ }
        \State \texttt{CUT}$(H,x,y)$
        \State \texttt{CASCADING-CUT}$(H,y)$
        \EndIf
        \State add $x$'s child list to the root list of $H$
        \State remove $x$ from the root list of $H$
        \EndIf

        \EndFunction
      \end{algorithmic}

      \begin{enumerate}
        \item The professor's claim that this procedure runs faster is based partly on the assumption that line 7 can be performed in $O(1)$ actual
          time. What is wrong with this assumption?

        \item Give a good upper bound on the actual time of \texttt{PISANO-DELETE} when $x$ is not $H.min$. Your bound should be in terms of
          $x.degree$ and the number $c$ of calls to the \texttt{CASCADING-CUT} procedure.

        \item
          Suppose that we call \texttt{PISANO-DELETE}$(H,x)$ and let $H'$ be the Fibonacci heap that results. Assuming that node $x$ is not a root,
          bound the potential of $H'$ in terms of $x.degree, c, t(H)$, and $m(H)$.

        \item
          Conclude that the amortized time for \texttt{PISANO-DELETE} is asymptotically no better than for \texttt{FIB-HEAP-DELETE}, even when $x \neq
          H.min$.
      \end{enumerate}

      Use the potential function $\varphi(H) = t(H) + 2 m(H)$.

    \end{problem}

    \begin{solution}

    \end{solution}

  \item
    \begin{problem}
      Suppose that a sequence of update operations is performed on a persistent red-black tree, $T$, starting from an initially-empty tree. Assume that
      $T$ is implemented using the limited node-copying method. Use the accounting method to prove that the amortized space cost of each update
      operation is $O(1)$. State clearly the invariant you use and the amortized cost that you assign to each update operation.
    \end{problem}

    \begin{solution}

    \end{solution}

  \item
    \begin{problem}
      Let $S=\{ p_i = (x_i,y_i), 1 \leq i \leq n \}$ be a set of $n$ points in the plane. Assume, for simplicity, that all points have positive and
      distinct $x$- and $y$-coordinates. We would like to pre-process $S$ into a data structure so that the following query can be answered
      efficiently:

      Given any query rectangle $q = [a,b] \times [0,c]$, resting on the $x$-axis, report the $x$-coordinates of the points of $S$ that are contained
      in $q$.

      The desired time bounds are $O(n)$ space, $O(n \log n)$ pre-processing time, and $O(K + \log n)$ query time, where $K$ is the number of reported
      points.

      Do the following:

      \begin{enumerate}
        \item
          Show how to build a data structure for this problem that is based on a persistent red-black tree. Describe briefly the main ideas and give
          pseudocode.

        \item
          Show how to query the structure. Describe briefly the main ideas, give pseudocode, and argue briefly why the query algorithm works.

        \item
          Analyze carefully the space, pre-processing time, and query time of your solution.

      \end{enumerate}

      Note: Assume you have available persistent counterparts to the routines for standard (i.e., non-persistent) red-black trees. Specifically, there
      are available routines \texttt{Insert(tree, key, time)}, \texttt{Delete(tree,key,time)}, \texttt{Search(tree, key, time)} to insert, delete, or
      search a key in a persistent red-black tree at some time instant, as well as a routine \texttt{Access-Range(tree, range, time)} to retrieve from
      a persistent red-black tree the $K$ keys that lie in some range (i.e., interval) at some time instant in $O(K + \log n)$ time. (You may not need
      all of these in your solution.) Assume that the ``limited node copying'' method is used. Treat the persisten red-black tree as a black-box and
      issue calls to the above routines as appropriate.

    \end{problem}

    \begin{solution}

      \begin{enumerate}
        \item

        \item

        \item

      \end{enumerate}

    \end{solution}

\end{enumerate}
\end{document}


